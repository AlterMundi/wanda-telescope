# Performance & Optimization Rules

## Performance Benchmarks

### Critical Operations
| Operation | Target | Maximum |
|-----------|--------|---------|
| Frame capture | < 100ms | 200ms |
| Still capture (full res) | < 500ms | 1000ms |
| Mount step | < 10ms | 20ms |
| API response | < 200ms | 500ms |
| Stream latency | < 200ms | 300ms |
| Session init | < 500ms | 1000ms |

## Memory Management

### Camera Operations
- Stream frames without accumulation
- Clear frame buffer after each capture
- Limit preview resolution to 1440x810
- Use MJPEG compression for streaming

### Session Management
- Process images immediately, don't queue
- Export metadata incrementally
- Clean up temporary files promptly
- Limit concurrent sessions to 1

## Threading Optimization

### Thread Pool Limits
- Mount controller: 1 tracking thread
- Session controller: 1 capture thread
- Web server: Thread per request (Flask default)
- Camera: Single-threaded with mutex

### Lock Granularity
```python
# Good - Fine-grained locking
with self._capture_lock:
    frame = self._capture_frame()
    
# Bad - Coarse locking
with self._global_lock:
    frame = self._capture_frame()
    self._process_frame(frame)
    self._save_frame(frame)
```

## Caching Strategies

### Configuration Caching
- Cache camera capabilities on init
- Cache mount calibration values
- Cache storage paths after first check

### Frame Buffering
- Single frame buffer for live view
- No buffering for still captures
- Configurable skip frames (default 3)

## Resource Optimization

### File I/O
- Use binary mode for images
- Buffer size: 64KB for file operations
- Async writes for session metadata

### Network Optimization
- MJPEG for efficient streaming
- Compression quality: 85% (configurable)
- Chunked transfer for large responses

## Performance Testing

### Benchmark Implementation
```python
import time
from functools import wraps

def benchmark(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        elapsed = time.perf_counter() - start
        logger.debug(f"{func.__name__} took {elapsed:.3f}s")
        return result
    return wrapper
```

### Load Testing
```bash
# Camera stress test
python tests/performance/camera_benchmark.py

# API load test (using Apache Bench)
ab -n 1000 -c 10 http://localhost:5000/capture_status

# Memory profiling
python -m memory_profiler main.py
```

## Optimization Priorities
1. **Responsiveness** - UI must feel instant
2. **Reliability** - Never drop frames or lose data
3. **Efficiency** - Minimize CPU/memory usage
4. **Scalability** - Handle long sessions gracefully