# WANDA Telescope Project - Cursor Rules

## Project Overview
WANDA (Wide-Angle Nightsky Digital Astrophotographer) is a Python-based astrophotography web application for Raspberry Pi. It provides a comprehensive web interface for controlling camera and equatorial mount for celestial object tracking.

## Core Architecture Patterns

### 1. Factory Pattern Implementation
- **Camera Factory**: `camera/factory.py` - Auto-detects hardware and creates appropriate implementations
  - PiCamera | USBCamera | MockCamera
- **Mount Factory**: `mount/factory.py` - Creates mount implementations
  - PiMount | MockMount

### 2. Abstract Base Classes
- **Camera Interface**: `camera/base.py` - AbstractCamera defines required interface
- **Mount Interface**: `mount/base.py` - Abstract mount interface for tracking control

### 3. Hardware Abstraction
- Mock implementations allow development without Raspberry Pi hardware
- Development mode automatically falls back to mocks when Pi hardware unavailable
- `dev_tools/` contains mock implementations of picamera2 and RPi.GPIO

## Key Components

### Camera System (`camera/`)
- Supports Raspberry Pi HQ Camera (IMX-477), Arducam UC-955 (Pivariety), USB webcams, and mock cameras
- Automatic camera detection and fallback (Pi → USB → Mock)
- Advanced exposure control, ISO adjustment, night vision mode
- State preservation for non-intrusive operation

### Mount Control (`mount/`)
- Stepper motor control for equatorial tracking
- Configurable tracking speed for sidereal rate
- Thread-safe operation with graceful shutdown

### Session Management (`session/`)
- Automated capture sessions with progress tracking
- Thread-based implementation for non-blocking operation
- JSON metadata export for each session

### Web Interface (`web/`)
- Flask-based REST API with AJAX frontend
- Real-time camera feed via MJPEG streaming
- Responsive design with collapsible control panels

## Development Guidelines

### 1. Test-Driven Development (TDD) - ALWAYS REQUIRED
- **ALWAYS work using TDD methodology**: Write tests first, then implement code.
- **No implementation without tests**: Every new feature must have corresponding tests.
- **Test coverage requirement**: Aim for at least 85% code coverage for all new code.
- **Test structure**: Follow the pattern: Arrange → Act → Assert (AAA).
- **Test naming**: Use descriptive test names that explain the scenario being tested.
- **Test organization**: Group related tests in classes and use clear test method names.
- **Mock strategy**: Use mocks for external dependencies (hardware, network, file system).
- **Error testing**: Include tests for error conditions and edge cases.

#### TDD Workflow:
1. **Write failing test** - Define the expected behavior
2. **Write minimal code** - Make the test pass
3. **Refactor** - Improve code while keeping tests green
4. **Repeat** - Continue the cycle for new features

#### Test Requirements:
- **Unit tests** for all functions and methods
- **Integration tests** for component interactions
- **Error handling tests** for exception scenarios
- **Edge case tests** for boundary conditions
- **Mock tests** for hardware dependencies
- **Performance tests** for critical operations (camera, motor control)
- **Hardware simulation tests** for development environments

### 2. Code Quality Standards

#### Simplicity
- Write clear, concise, and maintainable code.
- Favor straightforward solutions over complex abstractions.
- Use descriptive variable/function names that reflect astronomical or hardware context (e.g., telescope_altitude, move_stepper).
- Avoid over-engineering; prioritize readability for contributors with varying expertise.

#### Avoid Duplication
- Reuse existing functions, classes, or modules to prevent redundant code.
- Refactor duplicated logic into shared utilities in a utils/ or common/ module.
- Use constants for repeated values (e.g., MOTOR_STEP_ANGLE = 1.8).
- Ensure shared code is well-documented and tested before reuse.

#### Code Organization
- Keep files under 300 lines where possible for maintainability.
- Exceptions allowed for core modules (e.g., main.py, telescope_control.ino) if readability is maintained.
  - Use clear section comments (e.g., // Motor Control, # Data Processing) to break up long files.
- Refactor into modules when logical (e.g., separate motor_control.py, sensor_utils.py).
- Follow project structure:
  - Python: Place modules in src/ or lib/.
  - Arduino: Use .ino for main sketch, .h for helper libraries.
  - Tests: Store in tests/ with clear naming (e.g., test_motor_control.py).
- Use consistent file naming: lowercase with underscores (e.g., telescope_utils.py).

### 3. Change Control
- Only implement requested changes or fixes.
- Do not introduce new patterns, libraries, or frameworks unless:
  - Existing solutions are demonstrably insufficient (e.g., performance bottlenecks or missing functionality).
  - Rationale is documented in commit messages and a docs/rationale.md file.
- Before removing old code:
  - Validate new implementations with tests (e.g., unit tests for Python, hardware tests for Arduino).
  - Confirm changes align with project goals (e.g., telescope control accuracy).
- Preserve backward compatibility for existing hardware interfaces unless explicitly requested.
- **Breaking changes require**: Migration guide, deprecation warnings, and extended testing period.

## Important Implementation Details

### Camera State Management
- Camera controls are restored to original values after use
- Proper cleanup on application shutdown via signal handlers
- Thread-safe operations for concurrent access

### Storage Hierarchy
Storage locations are checked in order:
1. USB drive (if mounted at /media/*)
2. User home directory (~/wanda_captures)
3. Current directory fallback

### Error Handling
- Camera exceptions in `camera/exceptions.py`
- Mount exceptions follow similar pattern
- Web routes return appropriate HTTP status codes with error messages

## Development Commands

### Running the Application
```bash
# Automated setup and run (recommended)
./run-wanda.sh

# Manual run (if virtual environment already exists)
source venv/bin/activate
python main.py
```

### Testing
```bash
# Run all tests
pytest

# Run specific test categories
pytest tests/unit/          # Unit tests only
pytest tests/integration/   # Integration tests only
pytest tests/web/          # Web interface tests only

# Run with coverage
pytest --cov=camera,mount,web,utils

# Run a single test file
pytest tests/unit/test_camera_base.py

# Run a specific test
pytest tests/unit/test_camera_base.py::test_abstract_camera_interface
```

### Development Environment
```bash
# Create virtual environment manually
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Install development dependencies (for testing)
pip install pytest pytest-cov
```

## Testing Strategy
- Comprehensive fixtures in `tests/conftest.py`
- Mock hardware for CI/CD compatibility
- Integration tests verify component interactions
- Web tests use Flask test client

## Configuration
Main configuration in `config.py`:
- Camera settings (resolution, exposure limits, gain ranges)
- Mount settings (GPIO pins, step sequences, tracking speeds)
- Storage paths and web server settings
- All settings have sensible defaults

## Development Tips

1. **Running without hardware**: The application automatically uses mock implementations when Pi hardware is unavailable
2. **Camera testing**: Use MOCK_CAMERA environment variable to force mock camera even on Pi
3. **Mount testing**: Mock mount allows testing tracking logic without stepper motor
4. **Web development**: Frontend uses vanilla JavaScript with AJAX for simplicity
5. **Session testing**: Mock implementations support full session workflows

## Camera Hardware Support

WANDA supports multiple camera types through its factory pattern. The system automatically detects and uses the best available camera in this order: Pi Camera → USB Camera → Mock Camera.

### 1. Raspberry Pi Camera (PiCamera)
**Supported Models:**
- **Raspberry Pi HQ Camera (IMX-477)**: Official Pi camera module
- **Arducam UC-955 (Pivariety)**: High-performance IMX477-based camera
- **Other Pi-compatible cameras**: Any camera using the CSI interface

**Features:**
- Native libcamera/picamera2 integration
- Advanced exposure control and gain adjustment
- Night vision mode with enhanced sensitivity
- State preservation for non-intrusive operation
- Retry logic with detailed error diagnostics

**Setup Requirements:**
- Raspberry Pi 5 (recommended) or Pi 4
- Raspberry Pi OS Bookworm
- CSI camera ribbon cable connection
- libcamera and picamera2 packages

### 2. Arducam UC-955 (Pivariety) Specific Setup
For Arducam UC-955 camera modules, special driver installation is required. See `docs/ARDUCAM_UC955_SETUP.md` for complete setup instructions including:
- Official Arducam Pivariety driver installation
- Device tree overlay configuration (`dtoverlay=arducam-pivariety`)
- Required tuning file setup for libcamera compatibility
- Verification and troubleshooting steps

**Specifications:**
- Resolution: 1920x1080 @ 60fps
- Color depth: 10-bit RGGB
- Interface: CSI-2 via ribbon cable
- Integration: Seamless with WANDA's camera factory system

### 3. USB Camera (USBCamera)
**Supported Models:**
- Any USB webcam with UVC (USB Video Class) support
- Logitech, Microsoft, generic USB cameras
- USB 2.0 and USB 3.0 cameras

**Features:**
- OpenCV-based capture with MJPG format support
- Automatic resolution detection (1280x720 default)
- Exposure and gain control via camera properties
- Performance mode optimization
- Hardware state preservation

**Setup Requirements:**
- USB camera connected to any USB port
- OpenCV with video capture support
- UVC driver support (standard on Linux)

**Configuration:**
- Default resolution: 1280x720
- MJPG format for better performance
- Enhanced brightness for better visibility
- Automatic fallback if Pi camera unavailable

### 4. Mock Camera (MockCamera)
**Purpose:**
- Development and testing without hardware
- CI/CD pipeline compatibility
- Demo and presentation purposes

**Features:**
- Generates synthetic image data or uses webcam if available
- Full API compatibility with real cameras
- Configurable exposure and gain simulation
- Night vision mode simulation
- No hardware dependencies

**Usage:**
- Automatically used when no physical camera is detected
- Can be forced with `MOCK_CAMERA` environment variable
- Perfect for development and testing workflows

### Camera Detection Priority
The camera factory automatically detects cameras in this order:
1. **Pi Camera**: Highest priority for optimal performance
2. **USB Camera**: Fallback for non-Pi systems or additional cameras
3. **Mock Camera**: Development and testing fallback

### Hardware Requirements Summary
- **Pi Camera**: Raspberry Pi with CSI interface
- **USB Camera**: Any system with USB ports and UVC support
- **Mock Camera**: No hardware requirements (development only)

### Troubleshooting
- **Pi Camera Issues**: Check CSI cable connection and libcamera installation
- **USB Camera Issues**: Verify UVC driver support and USB port functionality
- **Detection Problems**: Use `camera/factory.py` detection methods for debugging

## picamera2 Library Deep Dive

### Core Architecture
The `picamera2` library is the official Python interface for Raspberry Pi cameras, built on top of the `libcamera` stack. It provides high-performance camera access with modern camera APIs.

#### Key Components
- **Picamera2**: Main camera class that manages camera lifecycle
- **H264Encoder**: Hardware-accelerated video encoding
- **FileOutput**: Output handling for file-based operations
- **Camera Controls**: Real-time parameter adjustment (exposure, gain, etc.)

#### Import Strategy Implementation
Due to virtual environment limitations, WANDA uses a multi-strategy import approach in `camera/implementations/pi_camera.py`:

```python
def _import_picamera2(self):
    """Import picamera2 modules only when needed."""
    import_strategies = [
        lambda: (__import__('picamera2').Picamera2, 
                __import__('picamera2.encoders').H264Encoder, 
                __import__('picamera2.outputs').FileOutput),
        lambda: self._import_from_system_path(),
        lambda: self._import_via_subprocess()
    ]
    
    for i, strategy in enumerate(import_strategies):
        try:
            return strategy()
        except Exception as e:
            if i == len(import_strategies) - 1:
                error_msg = f"All import strategies failed: {e}"
                logger.error(error_msg)
                raise ImportError(error_msg)
            logger.warning(f"Import strategy {i+1} failed: {e}")
```

#### System Path Integration
The critical fix for virtual environment compatibility:

```python
def _import_from_system_path(self):
    """Try to import picamera2 from system Python path."""
    import sys
    sys.path.append('/usr/lib/python3/dist-packages')  # Key fix
    
    try:
        from picamera2 import Picamera2
        from picamera2.encoders import H264Encoder
        from picamera2.outputs import FileOutput
        logger.info("picamera2 imported successfully from system path")
        return Picamera2, H264Encoder, FileOutput
    except Exception as e:
        logger.warning(f"System path import strategy failed: {e}")
        raise ImportError("Could not import picamera2 from system path")
```

### Camera Lifecycle Management

#### 1. Initialization
```python
def initialize(self):
    """Initialize the camera."""
    try:
        # Import picamera2 modules
        Picamera2, H264Encoder, FileOutput = self._import_picamera2()
        
        # Create camera instance
        self.camera = Picamera2()
        
        # Get camera info
        camera_info = self.camera.global_camera_info()
        if camera_info:
            logger.info(f"Camera info: {camera_info}")
        
        # Configure preview mode
        preview_config = self.create_preview_configuration()
        self.camera.configure(preview_config)
        
        # Start camera
        self.camera.start()
        self.started = True
        
        # Apply initial settings
        self.update_camera_settings()
        
        logger.info("Pi camera initialized successfully")
        
    except Exception as e:
        logger.error(f"Failed to initialize Pi camera: {e}")
        raise
```

#### 2. Configuration Management
```python
def create_preview_configuration(self, main=None):
    """Create preview configuration for live view."""
    if not main:
        main = {"size": (1440, 810)}  # Optimal for web streaming
    return {"main": main}

def create_still_configuration(self, main=None, raw=None):
    """Create still image configuration for high-res capture."""
    if not main:
        main = {"size": (4056, 3040)}  # Full IMX477 resolution
    config = {"main": main}
    if raw:
        config["raw"] = {"size": (4056, 3040)}
    return config
```

#### 3. Frame Capture Methods

##### Live View (High Frame Rate)
```python
def get_frame(self):
    """Get a frame as JPEG data for live streaming."""
    try:
        frame = self.capture_array()
        if frame is not None:
            # Apply digital gain if enabled
            if self.use_digital_gain and self.digital_gain > 1.0:
                frame = np.clip(frame * self.digital_gain, 0, 255).astype(np.uint8)
            
            # Convert RGB to BGR for OpenCV
            if len(frame.shape) == 3 and frame.shape[2] == 3:
                frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            
            # Encode to JPEG
            _, jpeg = cv2.imencode('.jpg', frame)
            return jpeg.tobytes()
    except Exception as e:
        logger.error(f"Error getting frame: {e}")
    return None
```

##### Still Image Capture
```python
def capture_array(self, name="main"):
    """Capture a frame as a numpy array."""
    if not self.camera:
        raise Exception("Camera not initialized")
    
    try:
        # Skip frames for exposure adjustment
        for _ in range(self.skip_frames):
            pass
        
        # Use native picamera2 capture
        array = self.camera.capture_array(name)
        return array
    except Exception as e:
        logger.error(f"Failed to capture array: {e}")
        raise
```

### Performance Optimization

#### Frame Rate Considerations
- **Live View**: 1440x810 resolution for optimal web streaming performance
- **Still Capture**: Full 4056x3040 resolution for maximum quality
- **Skip Frames**: Configurable frame skipping for exposure adjustment
- **Digital Gain**: Post-processing gain for low-light enhancement

#### Memory Management
- **Streaming**: Continuous frame capture without memory accumulation
- **Cleanup**: Proper camera stop/start for configuration changes
- **State Preservation**: Maintains camera settings across operations

### Error Handling and Fallbacks

#### Import Failures
1. **Direct Import**: Try standard Python import
2. **System Path**: Add `/usr/lib/python3/dist-packages` to sys.path
3. **Subprocess Fallback**: Use rpicam commands as last resort

#### Hardware Failures
- **Camera Unavailable**: Falls back to USB camera or mock camera
- **Configuration Errors**: Logs detailed error information
- **State Recovery**: Attempts to restore camera to working state

### Development Best Practices

#### 1. Always Test Import Strategy
```python
# Test picamera2 availability before implementation
try:
    from picamera2 import Picamera2
    HAS_PICAMERA2 = True
except ImportError:
    HAS_PICAMERA2 = False
```

#### 2. Use Native Methods When Possible
```python
# Preferred: Native picamera2 methods
frame = self.camera.capture_array()

# Avoid: Subprocess alternatives (slower, less reliable)
# subprocess.run(['rpicam-still', '--output', '-'])
```

#### 3. Handle Configuration Changes Properly
```python
def update_camera_settings(self):
    """Update camera settings without stopping stream."""
    if self.camera and self.started:
        try:
            self.camera.set_controls({
                "ExposureTime": self.exposure_time,
                "AnalogueGain": self.analogue_gain
            })
        except Exception as e:
            logger.warning(f"Failed to update camera settings: {e}")
```

#### 4. Monitor Performance
```python
import time

def benchmark_capture(self, num_frames=100):
    """Benchmark frame capture performance."""
    start_time = time.time()
    for _ in range(num_frames):
        frame = self.capture_array()
    end_time = time.time()
    
    fps = num_frames / (end_time - start_time)
    logger.info(f"Capture performance: {fps:.2f} FPS")
    return fps
```

### Troubleshooting Common Issues

#### Import Errors
- **ModuleNotFoundError**: Check if system packages are installed
- **Version Conflicts**: Ensure numpy compatibility between venv and system
- **Path Issues**: Verify `/usr/lib/python3/dist-packages` exists

#### Performance Issues
- **Low Frame Rate**: Check resolution settings and skip_frames
- **High Memory Usage**: Monitor frame cleanup and streaming patterns
- **Configuration Delays**: Minimize camera stop/start cycles

#### Hardware Issues
- **Camera Not Detected**: Verify CSI cable connection and device tree overlays
- **Configuration Failures**: Check camera permissions and libcamera status
- **Streaming Problems**: Test with rpicam-vid command line tool

## Raspberry Pi Ecosystem Constraints

⚠️ **Critical Understanding**: WANDA development is constrained by fundamental Raspberry Pi ecosystem limitations that require specific development practices.

### Package Management Reality
- **System Dependencies**: picamera2, libcamera, RPi.GPIO MUST be system packages (apt)
- **Binary Compatibility**: Virtual environment packages must match system compilation versions
- **Version Constraints**: numpy <2.0.0 required for picamera2 compatibility
- **OpenCV Special Case**: Must use pip version due to Pi camera integration requirements

### Development Environment Requirements
- **Real Hardware Testing**: Always test on actual Raspberry Pi, not development machines
- **Fresh Installation Testing**: Test automated installation from scratch, not incremental updates
- **Dependency Validation**: Verify system + venv package combinations work together
- **Log Analysis**: Check for "Mock PiCamera" vs "picamera2.picamera2" to confirm real hardware usage

### Architecture Implications
- **Multi-Layer Integration**: Hardware → Kernel → System → Python → Virtual Environment
- **Failure Fallbacks**: Implement subprocess wrappers when direct library access fails
- **Permission Management**: DMA heap devices, video group membership, udev rules
- **Hardware Configuration**: Device tree overlays, memory allocation, GPIO setup

### Platform Limitations Awareness
- **Rapid Evolution**: Camera stack, OS updates, hardware variants create moving targets
- **Compatibility Matrix**: Different requirements for Pi 4 vs Pi 5, Bullseye vs Bookworm
- **Production Considerations**: Ecosystem limitations may require platform alternatives for deployment

### Testing Strategy
- **Hardware Mocking**: Essential for development, but insufficient for validation
- **Integration Testing**: Must include real camera capture AND live feed verification
- **Version Matrix Testing**: Test across Pi models and OS versions
- **Automated Installation**: Validate complete setup process, not just code functionality

## Additional Notes
- Comment critical logic (e.g., coordinate calculations, motor timing) with purpose and context.
- Use docstrings for Python functions/classes and inline comments for Arduino.
- Ensure code runs on target hardware (e.g., Arduino Uno, Raspberry Pi) and specify dependencies in requirements.txt or README.md.
- Adhere to PEP 8 for Python.
- **Test files should be comprehensive**: Include positive tests, negative tests, and edge cases.
- **Test documentation**: Use docstrings in test methods to explain test purpose and expected behavior.
- **Hardware abstraction**: Use mock implementations for development and testing without physical hardware.
- **Error logging**: Implement comprehensive logging for debugging hardware issues in production.
- **Ecosystem Documentation**: Reference `docs/RASPBERRY_PI_ECOSYSTEM_LIMITATIONS.md` for detailed platform constraints.