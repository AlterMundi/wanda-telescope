# WANDA Telescope Project - Cursor Rules

## Project Overview
WANDA (Wide-Angle Nightsky Digital Astrophotographer) is a Python-based astrophotography web application for Raspberry Pi. It provides a comprehensive web interface for controlling camera and equatorial mount for celestial object tracking.

## Core Architecture Patterns

### 1. Factory Pattern Implementation
- **Camera Factory**: `camera/factory.py` - Auto-detects hardware and creates appropriate implementations
  - PiCamera | USBCamera | MockCamera
- **Mount Factory**: `mount/factory.py` - Creates mount implementations
  - PiMount | MockMount

### 2. Abstract Base Classes
- **Camera Interface**: `camera/base.py` - AbstractCamera defines required interface
- **Mount Interface**: `mount/base.py` - Abstract mount interface for tracking control

### 3. Hardware Abstraction
- Mock implementations allow development without Raspberry Pi hardware
- Development mode automatically falls back to mocks when Pi hardware unavailable
- `dev_tools/` contains mock implementations of picamera2 and RPi.GPIO

## Key Components

### Camera System (`camera/`)
- Supports Raspberry Pi HQ Camera (IMX-477), Arducam UC-955 (Pivariety), USB webcams, and mock cameras
- Automatic camera detection and fallback (Pi → USB → Mock)
- Advanced exposure control, ISO adjustment, night vision mode
- State preservation for non-intrusive operation

### Mount Control (`mount/`)
- Stepper motor control for equatorial tracking
- Configurable tracking speed for sidereal rate
- Thread-safe operation with graceful shutdown

### Session Management (`session/`)
- Automated capture sessions with progress tracking
- Thread-based implementation for non-blocking operation
- JSON metadata export for each session

### Web Interface (`web/`)
- Flask-based REST API with AJAX frontend
- Real-time camera feed via MJPEG streaming
- Responsive design with collapsible control panels

## Development Guidelines

### 1. Test-Driven Development (TDD) - ALWAYS REQUIRED
- **ALWAYS work using TDD methodology**: Write tests first, then implement code.
- **No implementation without tests**: Every new feature must have corresponding tests.
- **Test coverage requirement**: Aim for at least 85% code coverage for all new code.
- **Test structure**: Follow the pattern: Arrange → Act → Assert (AAA).
- **Test naming**: Use descriptive test names that explain the scenario being tested.
- **Test organization**: Group related tests in classes and use clear test method names.
- **Mock strategy**: Use mocks for external dependencies (hardware, network, file system).
- **Error testing**: Include tests for error conditions and edge cases.

#### TDD Workflow:
1. **Write failing test** - Define the expected behavior
2. **Write minimal code** - Make the test pass
3. **Refactor** - Improve code while keeping tests green
4. **Repeat** - Continue the cycle for new features

#### Test Requirements:
- **Unit tests** for all functions and methods
- **Integration tests** for component interactions
- **Error handling tests** for exception scenarios
- **Edge case tests** for boundary conditions
- **Mock tests** for hardware dependencies
- **Performance tests** for critical operations (camera, motor control)
- **Hardware simulation tests** for development environments

### 2. Code Quality Standards

#### Simplicity
- Write clear, concise, and maintainable code.
- Favor straightforward solutions over complex abstractions.
- Use descriptive variable/function names that reflect astronomical or hardware context (e.g., telescope_altitude, move_stepper).
- Avoid over-engineering; prioritize readability for contributors with varying expertise.

#### Avoid Duplication
- Reuse existing functions, classes, or modules to prevent redundant code.
- Refactor duplicated logic into shared utilities in a utils/ or common/ module.
- Use constants for repeated values (e.g., MOTOR_STEP_ANGLE = 1.8).
- Ensure shared code is well-documented and tested before reuse.

#### Code Organization
- Keep files under 300 lines where possible for maintainability.
- Exceptions allowed for core modules (e.g., main.py, telescope_control.ino) if readability is maintained.
  - Use clear section comments (e.g., // Motor Control, # Data Processing) to break up long files.
- Refactor into modules when logical (e.g., separate motor_control.py, sensor_utils.py).
- Follow project structure:
  - Python: Place modules in src/ or lib/.
  - Arduino: Use .ino for main sketch, .h for helper libraries.
  - Tests: Store in tests/ with clear naming (e.g., test_motor_control.py).
- Use consistent file naming: lowercase with underscores (e.g., telescope_utils.py).

### 3. Change Control
- Only implement requested changes or fixes.
- Do not introduce new patterns, libraries, or frameworks unless:
  - Existing solutions are demonstrably insufficient (e.g., performance bottlenecks or missing functionality).
  - Rationale is documented in commit messages and a docs/rationale.md file.
- Before removing old code:
  - Validate new implementations with tests (e.g., unit tests for Python, hardware tests for Arduino).
  - Confirm changes align with project goals (e.g., telescope control accuracy).
- Preserve backward compatibility for existing hardware interfaces unless explicitly requested.
- **Breaking changes require**: Migration guide, deprecation warnings, and extended testing period.

## Important Implementation Details

### Camera State Management
- Camera controls are restored to original values after use
- Proper cleanup on application shutdown via signal handlers
- Thread-safe operations for concurrent access

### Storage Hierarchy
Storage locations are checked in order:
1. USB drive (if mounted at /media/*)
2. User home directory (~/wanda_captures)
3. Current directory fallback

### Error Handling
- Camera exceptions in `camera/exceptions.py`
- Mount exceptions follow similar pattern
- Web routes return appropriate HTTP status codes with error messages

## Development Commands

### Running the Application
```bash
# Automated setup and run (recommended)
./run-wanda.sh

# Manual run (if virtual environment already exists)
source venv/bin/activate
python main.py
```

### Testing
```bash
# Run all tests
pytest

# Run specific test categories
pytest tests/unit/          # Unit tests only
pytest tests/integration/   # Integration tests only
pytest tests/web/          # Web interface tests only

# Run with coverage
pytest --cov=camera,mount,web,utils

# Run a single test file
pytest tests/unit/test_camera_base.py

# Run a specific test
pytest tests/unit/test_camera_base.py::test_abstract_camera_interface
```

### Development Environment
```bash
# Create virtual environment manually
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Install development dependencies (for testing)
pip install pytest pytest-cov
```

## Testing Strategy
- Comprehensive fixtures in `tests/conftest.py`
- Mock hardware for CI/CD compatibility
- Integration tests verify component interactions
- Web tests use Flask test client

## Configuration
Main configuration in `config.py`:
- Camera settings (resolution, exposure limits, gain ranges)
- Mount settings (GPIO pins, step sequences, tracking speeds)
- Storage paths and web server settings
- All settings have sensible defaults

## Development Tips

1. **Running without hardware**: The application automatically uses mock implementations when Pi hardware is unavailable
2. **Camera testing**: Use MOCK_CAMERA environment variable to force mock camera even on Pi
3. **Mount testing**: Mock mount allows testing tracking logic without stepper motor
4. **Web development**: Frontend uses vanilla JavaScript with AJAX for simplicity
5. **Session testing**: Mock implementations support full session workflows

## Camera Hardware Support

WANDA supports multiple camera types through its factory pattern. The system automatically detects and uses the best available camera in this order: Pi Camera → USB Camera → Mock Camera.

### 1. Raspberry Pi Camera (PiCamera)
**Supported Models:**
- **Raspberry Pi HQ Camera (IMX-477)**: Official Pi camera module
- **Arducam UC-955 (Pivariety)**: High-performance IMX477-based camera
- **Other Pi-compatible cameras**: Any camera using the CSI interface

**Features:**
- Native libcamera/picamera2 integration
- Advanced exposure control and gain adjustment
- Night vision mode with enhanced sensitivity
- State preservation for non-intrusive operation
- Retry logic with detailed error diagnostics

**Setup Requirements:**
- Raspberry Pi 5 (recommended) or Pi 4
- Raspberry Pi OS Bookworm
- CSI camera ribbon cable connection
- libcamera and picamera2 packages

### 2. Arducam UC-955 (Pivariety) Specific Setup
For Arducam UC-955 camera modules, special driver installation is required. See `docs/ARDUCAM_UC955_SETUP.md` for complete setup instructions including:
- Official Arducam Pivariety driver installation
- Device tree overlay configuration (`dtoverlay=arducam-pivariety`)
- Required tuning file setup for libcamera compatibility
- Verification and troubleshooting steps

**Specifications:**
- Resolution: 1920x1080 @ 60fps
- Color depth: 10-bit RGGB
- Interface: CSI-2 via ribbon cable
- Integration: Seamless with WANDA's camera factory system

### 3. USB Camera (USBCamera)
**Supported Models:**
- Any USB webcam with UVC (USB Video Class) support
- Logitech, Microsoft, generic USB cameras
- USB 2.0 and USB 3.0 cameras

**Features:**
- OpenCV-based capture with MJPG format support
- Automatic resolution detection (1280x720 default)
- Exposure and gain control via camera properties
- Performance mode optimization
- Hardware state preservation

**Setup Requirements:**
- USB camera connected to any USB port
- OpenCV with video capture support
- UVC driver support (standard on Linux)

**Configuration:**
- Default resolution: 1280x720
- MJPG format for better performance
- Enhanced brightness for better visibility
- Automatic fallback if Pi camera unavailable

### 4. Mock Camera (MockCamera)
**Purpose:**
- Development and testing without hardware
- CI/CD pipeline compatibility
- Demo and presentation purposes

**Features:**
- Generates synthetic image data or uses webcam if available
- Full API compatibility with real cameras
- Configurable exposure and gain simulation
- Night vision mode simulation
- No hardware dependencies

**Usage:**
- Automatically used when no physical camera is detected
- Can be forced with `MOCK_CAMERA` environment variable
- Perfect for development and testing workflows

### Camera Detection Priority
The camera factory automatically detects cameras in this order:
1. **Pi Camera**: Highest priority for optimal performance
2. **USB Camera**: Fallback for non-Pi systems or additional cameras
3. **Mock Camera**: Development and testing fallback

### Hardware Requirements Summary
- **Pi Camera**: Raspberry Pi with CSI interface
- **USB Camera**: Any system with USB ports and UVC support
- **Mock Camera**: No hardware requirements (development only)

### Troubleshooting
- **Pi Camera Issues**: Check CSI cable connection and libcamera installation
- **USB Camera Issues**: Verify UVC driver support and USB port functionality
- **Detection Problems**: Use `camera/factory.py` detection methods for debugging

## Additional Notes
- Comment critical logic (e.g., coordinate calculations, motor timing) with purpose and context.
- Use docstrings for Python functions/classes and inline comments for Arduino.
- Ensure code runs on target hardware (e.g., Arduino Uno, Raspberry Pi) and specify dependencies in requirements.txt or README.md.
- Adhere to PEP 8 for Python.
- **Test files should be comprehensive**: Include positive tests, negative tests, and edge cases.
- **Test documentation**: Use docstrings in test methods to explain test purpose and expected behavior.
- **Hardware abstraction**: Use mock implementations for development and testing without physical hardware.
- **Error logging**: Implement comprehensive logging for debugging hardware issues in production.